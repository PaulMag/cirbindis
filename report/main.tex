\documentclass[a4paper, 12pt, english, titlepage]{article}

% Import packages:
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{graphicx, color}
\usepackage{parskip} % norwegian sections (skip line)
\usepackage{amsmath}
\usepackage{varioref} % fancy captions
\usepackage[margin=3cm]{geometry} % smaller margins
\usepackage{grffile} % ex­tended file name sup­port for graph­ics, allows periods in filenames
\usepackage{hyperref} % allows hyperlinks with the \href command

% Set code style:
\definecolor{darkgreen}{RGB}{0,135,0}
\usepackage{listings}
% \lstset{language=python}
\lstset{basicstyle=\ttfamily\scriptsize} % \small if short code
\lstset{frame=single} % creates the frame around code
% \lstset{title=\lstname} % display name of file, not necessary
\lstset{keywordstyle=\color{red}\bfseries}
\lstset{commentstyle=\color{blue}}
\lstset{stringstyle =\color{darkgreen}}
\lstset{showspaces=false}
\lstset{showstringspaces=false}
\lstset{showtabs=false}
\lstset{breaklines=true}
\lstset{tabsize=4}

% Custom commands:
%\newcommand{\nameOfCommand}[numberOfArguments]{command}
\newcommand{\erf}[1]{\textrm{erf}\left(#1\right)} % steps in integrals, ex: 4x \D{x} -> 4x dx
\newcommand{\D}[1]{\ \mathrm{d}#1} % steps in integrals, ex: 4x \D{x} -> 4x dx
\newcommand{\E}[1]{\cdot 10^{#1}}  % exponents, ex: 1.4\E{3} -> 1.4*10^3
\newcommand{\U}[1]{\, \textrm{#1}} % display units prettily, ex: 15.4\U{m} -> 15.4 m
\newcommand{\degree}{\, ^\circ}    % make a degree symbol
\newcommand{\sname}{\texttt{CirBinDis }}

\newcommand{\bilde}[3]{
    \begin{figure}[htbp]
        \centering
        \includegraphics[width=\textwidth]{#1}
        \caption{#3 \label{#2}}
    \end{figure}
}
\newcommand{\bildeto}[4]{
    \begin{figure}[htbp]
        \centering
        \includegraphics[width=0.96\textwidth]{#1}
        \includegraphics[width=0.96\textwidth]{#2}
        \caption{#4 \label{#3}}
    \end{figure}
}

% Opening:
\title{\sname \\ Circumbinary disk analyser}
\author{Paul Magnus Sørensen-Clark \\ Jerome Bouvier}

% Begin document:
\begin{document}

\maketitle
\tableofcontents

\vfill
Contact:

Paul Magnus Sørensen-Clark:
\href{mailto:paulmag91@gmail.com}{paulmag91@gmail.com}

Jerome Bouvier:
\href{mailto:jerome.bouvier@obs.ujf-grenoble.fr}{jerome.bouvier@obs.ujf-grenoble.fr}

\url{https://bitbucket.org/paulmag/circumbinarydisk}

\clearpage


%===============================================================================
\section{Introduction}
%-------------------------------------------------------------------------------

A small piece of software for receiving an artificial light curve from a simulated density map of a gas disk around a binary star.

This explains certain procedures with bash-commands, which exists in Linux/UNIX and Apple OS. \sname should work in Windows as well, but some bash-commads may be different.


%===============================================================================
\section{Installing}
%-------------------------------------------------------------------------------

The source code is available at this Bitbucket repository: \\
\url{https://bitbucket.org/paulmag/circumbinarydisk} \\
Provided that Git is installed on you computer you can easily get all the files by running the following command inside the folder where you want the repository: \\
\texttt{git clone https://paulmag@bitbucket.org/paulmag/circumbinarydisk.git} \\
This link will be updated if the location of the repository or the installation process in any other way changes (note that at this moment the repository is private).
Should it not work then contact the authors via email.

We recommended to make the alias \texttt{cirbindis} for the command \\
\texttt{python \textasciitilde/path\_to\_repository\_folder/circumbinarydisk/src/main.py}. \\
F. ex. place this in your \texttt{.bashrc} or \texttt{.bash\_aliases}:
\begin{verbatim}
    alias cirbindis="python ~/GitHub/circumbinarydisk/src/main.py"
\end{verbatim}
This alias will be assumed for the rest of this manual.


%===============================================================================
\section{Preparing your data}
%-------------------------------------------------------------------------------

The format of the input data must be an ASCII/CSV-file with three columns where each line represents a datapoint in space. The two first columns of each line represent the position of a datapoint. $(x, y)$ if using cartesian coordinates and $(r, \theta)$ if using polar coordinates. The last column represents the density in this position.

Any units can be used for the input data. How to specify units are covered in the section \textbf{Configuring and running \sname}.

(It is currently possible to have four instead of three. Then the three first columns represent $(x, y, z)$ or $(r, \theta, z)$. The use of 3D-datapoints is currently an obsolete feature that will probably be completely removed.)


%===============================================================================
\section{Processing algorithm}
%-------------------------------------------------------------------------------

\sname produces artificial lightcurves by analysing the provided dataset according to given configurations. In this section the process for extracting the lightcurve from the dataset is explained.

\subsection{Loading data}
    %TODO
    \textbf{TODO}

\subsection{Cropping}
    The space covered by the dataset may represent a larger area than the disk you want to analyse. The dataset is cropped to an inner and outer radius such that the shape of the remaining datapoints resembles a donut. The outer radius represents the size of the disk and makes sure that the disk is circular. The inner radius is necessary to avoid treating the stars themselves as dust, and the density of the dust is very low close to the stars anyway.

\subsection{Rotating}
    The coordinates of all datapoints are rotated stepwise with the rotation
    matrix $R_z$ for $\theta = [0, 360)\degree$.
    $$
    R_z = \begin{bmatrix}
        \cos(\theta) & -\sin(\theta) &              0 \\
        \sin(\theta) &  \cos(\theta) &              0 \\
                   0 &             0 &              1 \\
    \end{bmatrix}
    $$
    This rotation simulates the physical orbital rotation of the dircumbinary
    disk. The reason we get a variation in the lightcurve is because when the
    disk rotates we see the stars through different areas of the disk with
    different densities.

    A rotation also happens around the $y$-axis due to the inclination angle $\phi$. $R_y$ is the rotation matrix which would perform this rotation. However, $R_y$ is \emph{not} used, and the $y$-rotation is never performed directly. It is implicitly done in a very different way in a following section \textbf{Mean density of bins, weighted and integrated}.
    $$
    R_y = \begin{bmatrix}
        \cos(\phi) &          0 & \sin(\phi) \\
                 0 &          1 &          0 \\
        \sin(\phi) &          0 & \cos(\phi) \\
    \end{bmatrix}
    $$

\subsection{Sylinder}
    A section of the datapoints are cropped out, which represents only the sylinder of gas that is between an observer on Earth and the star. These are the datapoints that fall within the sylinder whose base area is defined by the stellar surface and which extends from the stellar surface and infinitely along the $x$-axis in positive direction (the de facto limit is the outer radius of the disk). In other words, the observer's position is assumed to be $(\infty, 0, 0)$. A sylinder like this is made once for \emph{each} azimuthal rotation of all the points. Thus, each sylinder will be a little different from the previous one (if $\D\theta$ is small). If there are two (or even more) stars a sylinder will be created for the line of sight of each star, so there can be two (or even more) sylinders at the same time.

\subsection{Binning}

    \subsubsection{Algorithm}
        Each sylinder is sliced up into $n_{steps}$ bins along the line of sight, where $n_{steps}$ is given by the field \texttt{radiussteps} in \texttt{input.xml}. $N_{sylinder}$ is the number of datapoints contained within a sylinder. For each bin the mean density is computed. The binning algorithm works like this:
        \begin{enumerate}
            \item Sort all datapoints in sylinder according to $x$-component.
            \item Find $N_{bin} = N_{sylinder} / n_{steps}$.
            \item First $N_{bin}$ (sorted) datapoints goes in the first bin, next $N_{bin}$ datapoints go in the second bin, etc.
            \item Create corresponding $\D r$ array, where the $\D r$ corresponding the each bin is the difference between the $x$-component of the first and last datapoint in that bin.
        \end{enumerate}

    \subsubsection{Reasoning}
        An alternative way this could be done is have a static $\Delta r$ and check which points fall within $[r, r + \D r]$ for $r$ in $[0, 1, 2, 3 \hdots]\cdot\Delta r$, but this requires a boolean test on the entire sylinder for each radius. It is much faster to sort the datapoints in the sylinder once and then just slice it with indices. There could be even smarter ways to do it, but this has worked well for now. A side effect of this method is that $\Delta r$ is smaller in areas where there are more datapoints. If the grid of datapoints is spaced denser in central areas where the most interesting features are this is a bonus compared to a static $\Delta r$.


\subsection{Mean density of bins, weighted and integrated}
    For each bin a mean density is produced from all the datapoints in that bin. Each point is also projected vertically up from the disk (orthogonal to the disk plane) and into the area it represents in a sylinder that is inclined with respect to the disk.

    $\rho(z)$ is the assumed density at a point with altitude $z$ above a point in the disk plane with density $\rho_0$.
    $$
    \rho(z) = \rho_0 \exp\left(- \frac{z^2}{2H^2}\right)
    $$
    Each density point is given a weight according to where it is in the sylinder. Points closer to the middle of the sylinder gains larger weight because they represent its fulll height and thus a larger area than points near the edges.
    (\textbf{TODO:} There needs to be a figure of this to illustrate it more cleary.)
    $$
    W_i(y) = \frac{\sqrt{r_{star}^2 - (y_i - y_{star})^2}}{\cos(\phi)}
    $$
    The factor $1/\cos(\phi)$ adjusts the height of the sylinder if it is inclined so that it is always shaped like a circular sylinder.

    To get the density inside the entire area of the slice of the sylinder and the variations in density from different altitudes we integrate the density for each point, projected from the bottom ($z_a$) to the top ($z_b$) of the sylinder. The distance to integrate is $2W_i$ for each point, centered around $z_i$.
    \begin{align*}
        z_i &= (x_i - x_{star}) \cdot \tan(\phi) \\
        z_{i,a} &= z_i - W_i \\
        z_{i,b} &= z_i + W_i
    \end{align*}
    $\exp(-z^2)$ is the gaussian. It's integral has no analytical solution, but it can be approximated by the error function (erf), which is a power series. erf is provided in the Python library SciPy (\texttt{scipy.special.erf}) and can handle arrays, which means that this integral can be performed for all the datapoints in the sylinder bin very quickly in a vectorized manner.
    \begin{align*}
        \lambda_i
        &= \int_{z_{i,a}}^{z_{i,b}} \rho_0 \exp\left(- \frac{z_i^2}{2H^2}\right) \D{z_i} \\
        &= \rho_0 \frac{\sqrt{\pi}}{2} \sqrt{2H^2}
        \left[ \erf{\frac{z_{i,b}}{\sqrt{2H^2}}} - \erf{\frac{z_{i,a}}{\sqrt{2H^2}}} \right] \\
        \rho_{\, bin} &= \frac{\sum_i \lambda_i}{\sum_i 2W_i}
    \end{align*}
    $\rho_{bin}$ is thus the mean density of one bin of the sylinder, and it has a corresponding $\Delta r$. A $\rho_{bin}$, $\Delta r$ pair is calculated for each of the $N_{bin}$ bins in each sylinder.


\subsection{Integrating}
    %TODO
    \textbf{TODO}


%===============================================================================
\section{Configuring and running \sname}
%-------------------------------------------------------------------------------

How to make necessary configurations and then run \sname to perform an analysis.

This is the most practical and maybe the most important section, as it explains how to actually use the software.

\subsection{Input parameters}
    The input parameters for each run of \sname is configured in an XML file. Inside the repository you will find \texttt{/xml/input.xml}. Copy this file to the path where you will run \sname from (normally the folder where the input datafile is) and change the value of the fields as required (it must still be called \texttt{input.xml}). Specifically, this is where you provide the filename of the dataset to analyse (if \texttt{input.xml} is in another folder than the input datafile you need to provide the relative path).

    %TODO
    \textbf{TODO}: Here I plan to more or less copy the explanations that are in \texttt{input.xml} already.

    \begin{description}
        \item[unit-mass] Dorem
        \item[unit-distance] ipsum
        \item[unit-intensity] dolum
    \end{description}

\subsection{Executing the code}
    When you have prepared \texttt{input.xml} and you are located in it's folder, type the command \texttt{cirbindis} \\
    (or \texttt{python \textasciitilde/path\_to\_repository\_folder/circumbinarydisk/src/main.py}).
    Then the software will run until it has completed the analysis of your datafile with all the parameters you specified.

\subsection{Output}
    %TODO
    \textbf{TODO}

%===============================================================================
\section{Bibliography}
%-------------------------------------------------------------------------------


%===============================================================================
\section{Acknowledgments}
%-------------------------------------------------------------------------------


%===============================================================================
\section{Source code}
%-------------------------------------------------------------------------------

\subsection{\texttt{input.xml}}
    The file for the user to provide input parameters to \sname. You can copy and modify it. It is not a part of the source code itself.
    \lstinputlisting[language=XML]{../xml/input.xml}

\subsection{\texttt{main.py}}
    The script that is called when running \sname.
    \lstinputlisting[language=Python]{../src/main.py}

\subsection{\texttt{DensityMap.py}}
    Contains the class \texttt{DensityMap} for making an instance of a dataset representing a circumbinary disk. It contains most methods that can be performed on the data. Also contains a subclass \texttt{Sylinder}. Sylinders a sub-sets of a full dataset.
    \lstinputlisting[language=Python]{../src/DensityMap.py}

\subsection{\texttt{Star.py}}
    The simple \texttt{Star} class whose intention is to hold the physical parameters of each star.
    \lstinputlisting[language=Python]{../src/Star.py}

\subsection{\texttt{Functions.py}}
    A file containing some general functions that are used other places in the program.
    \lstinputlisting[language=Python]{../src/Functions.py}

\subsection{\texttt{plot.py}}
    A standalone script that can be used to plot the output of \sname. You can just as well use f.ex. TOPCAT.
    \lstinputlisting[language=Python]{../src/plot.py}

\subsection{\texttt{make\_testdata.py}}
    A standalone script that can be used to generate artificial datasets that can be analysed by \sname. You can use it for testing and for generating data according to any analytical function that you would like to analyse (then you need to change the function \texttt{density}).
    \lstinputlisting[language=Python]{../src/make_testdata.py}


\end{document}
